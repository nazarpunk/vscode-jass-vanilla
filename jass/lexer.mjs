import {createToken, Lexer} from 'chevrotain';

export const JassTokenMap = {
    whitespace: createToken({
        name: 'whitespace',
        pattern: /[^\S\r\n]+/,
        line_breaks: false,
        group: Lexer.SKIPPED,
    }),
    comment: createToken({
        name: 'comment',
        pattern: /\/\/[^\r\n]*/,
        line_breaks: false,
    }),
    type: createToken({
        name: 'type',
        pattern: /\btype\b/,
        start_chars_hint: ["t"],
        line_breaks: false,
    }),
    extends: createToken({
        name: 'extends',
        pattern: /\bextends\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    constant: createToken({
        name: 'constant',
        pattern: /\bconstant\b/,
        start_chars_hint: ["c"],
        line_breaks: false,
    }),
    native: createToken({
        name: 'native',
        pattern: /\bnative\b/,
        start_chars_hint: ["n"],
        line_breaks: false,
    }),
    function: createToken({
        name: 'function',
        pattern: /\bfunction\b/,
        start_chars_hint: ["f"],
        line_breaks: false,
    }),
    takes: createToken({
        name: 'takes',
        pattern: /\btakes\b/,
        start_chars_hint: ["t"],
        line_breaks: false,
    }),
    nothing: createToken({
        name: 'nothing',
        pattern: /\bnothing\b/,
        start_chars_hint: ["n"],
        line_breaks: false,
    }),
    returns: createToken({
        name: 'returns',
        pattern: /\breturns\b/,
        start_chars_hint: ["r"],
        line_breaks: false,
    }),
    local: createToken({
        name: 'local',
        pattern: /\blocal\b/,
        start_chars_hint: ["l"],
        line_breaks: false,
    }),
    and: createToken({
        name: 'and',
        pattern: /\band\b/,
        start_chars_hint: ["a"],
        line_breaks: false,
    }),
    or: createToken({
        name: 'or',
        pattern: /\bor\b/,
        start_chars_hint: ["o"],
        line_breaks: false,
    }),
    call: createToken({
        name: 'call',
        pattern: /\bcall\b/,
        start_chars_hint: ["c"],
        line_breaks: false,
    }),
    not: createToken({
        name: 'not',
        pattern: /\bnot\b/,
        start_chars_hint: ["n"],
        line_breaks: false,
    }),
    set: createToken({
        name: 'set',
        pattern: /\bset\b/,
        start_chars_hint: ["s"],
        line_breaks: false,
    }),
    loop: createToken({
        name: 'loop',
        pattern: /\bloop\b/,
        start_chars_hint: ["l"],
        line_breaks: false,
    }),
    then: createToken({
        name: 'then',
        pattern: /\bthen\b/,
        start_chars_hint: ["t"],
        line_breaks: false,
    }),
    exitwhen: createToken({
        name: 'exitwhen',
        pattern: /\bexitwhen\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    endloop: createToken({
        name: 'endloop',
        pattern: /\bendloop\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    elseif: createToken({
        name: 'elseif',
        pattern: /\belseif\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    else: createToken({
        name: 'else',
        pattern: /\belse\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    endif: createToken({
        name: 'endif',
        pattern: /\bendif\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    endfunction: createToken({
        name: 'endfunction',
        pattern: /\bendfunction\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    comma: createToken({
        name: 'comma',
        pattern: /,/,
        start_chars_hint: [","],
        label: ",",
        line_breaks: false,
    }),
    equalsequals: createToken({
        name: 'equalsequals',
        pattern: /==/,
        start_chars_hint: ["="],
        line_breaks: false,
        label: "==",
    }),
    equals: createToken({
        name: 'equals',
        pattern: /=/,
        start_chars_hint: ["="],
        line_breaks: false,
        label: "=",
    }),
    notequals: createToken({
        name: 'notequals',
        pattern: /!=/,
        start_chars_hint: ["!"],
        line_breaks: false,
        label: "!=",
    }),
    add: createToken({
        name: 'add',
        pattern: /\+/,
        start_chars_hint: ["+"],
        line_breaks: false,
        label: "+",
    }),
    sub: createToken({
        name: 'sub',
        pattern: /-/,
        start_chars_hint: ["-"],
        line_breaks: false,
        label: "-",
    }),
    mult: createToken({
        name: 'mult',
        pattern: /\*/,
        start_chars_hint: ["*"],
        line_breaks: false,
        label: "*",
    }),
    div: createToken({
        name: 'div',
        pattern: /\//,
        start_chars_hint: ["/"],
        line_breaks: false,
        label: "/",
    }),
    if: createToken({
        name: 'if',
        pattern: /if/,
        start_chars_hint: ["i"],
        line_breaks: false,
    }),
    stringliteral: createToken({
        name: 'stringliteral',
        pattern: /".*"/,
        start_chars_hint: ["\""],
        line_breaks: false,
    }),
    lparen: createToken({
        name: 'lparen',
        pattern: /\(/,
        start_chars_hint: ["("],
        line_breaks: false,
        label: "(",
    }),
    rparen: createToken({
        name: 'rparen',
        pattern: /\)/,
        start_chars_hint: [")"],
        line_breaks: false,
        label: ")",
    }),
    lsquareparen: createToken({
        name: 'lsquareparen',
        pattern: /\[/,
        start_chars_hint: ["["],
        line_breaks: false,
        label: "[",
    }),
    rsquareparen: createToken({
        name: 'rsquareparen',
        pattern: /]/,
        start_chars_hint: ["]"],
        line_breaks: false,
        label: "]",
    }),
    idliteral: createToken({
        name: 'idliteral',
        pattern: /'.*'/,
        line_breaks: false,
    }),
    integer: createToken({
        name: 'integer',
        pattern: /[0-9]+/,
        line_breaks: false,
    }),
    real: createToken({
        name: 'real',
        pattern: /[0-9]+\.[0-9]+/,
        line_breaks: false,
    }),
    linebreak: createToken({
        name: 'linebreak',
        pattern: /\n|\r\n/,
        label: "\\n",
        line_breaks: true,
    }),
    identifier: createToken({
        name: 'identifier',
        pattern: /[a-zA-Z][a-zA-Z0-9_]*/,
        line_breaks: false,
    }),
}

/** @type {import('chevrotain').TokenType[]} */
export const JassTokenList = [JassTokenMap.whitespace, JassTokenMap.comment, JassTokenMap.type, JassTokenMap.extends, JassTokenMap.constant, JassTokenMap.native, JassTokenMap.function, JassTokenMap.takes, JassTokenMap.nothing, JassTokenMap.returns, JassTokenMap.local, JassTokenMap.and, JassTokenMap.or, JassTokenMap.call, JassTokenMap.not, JassTokenMap.set, JassTokenMap.loop, JassTokenMap.then, JassTokenMap.exitwhen, JassTokenMap.endloop, JassTokenMap.elseif, JassTokenMap.else, JassTokenMap.endif, JassTokenMap.endfunction, JassTokenMap.comma, JassTokenMap.equalsequals, JassTokenMap.equals, JassTokenMap.notequals, JassTokenMap.add, JassTokenMap.sub, JassTokenMap.mult, JassTokenMap.div, JassTokenMap.if, JassTokenMap.stringliteral, JassTokenMap.lparen, JassTokenMap.rparen, JassTokenMap.lsquareparen, JassTokenMap.rsquareparen, JassTokenMap.idliteral, JassTokenMap.integer, JassTokenMap.real, JassTokenMap.linebreak, JassTokenMap.identifier];

export const JassLexer = new Lexer(JassTokenList);
for (const error of JassLexer.lexerDefinitionErrors) console.error(error);