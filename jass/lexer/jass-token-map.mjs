import {createToken, Lexer} from 'chevrotain';

export default {
    whitespace: createToken({
        name: 'whitespace',
        pattern: /[^\S\r\n]+/,
        line_breaks: false,
        group: Lexer.SKIPPED,
    }),
    comment: createToken({
        name: 'comment',
        pattern: /\/\/[^\r\n]*/,
        line_breaks: false,
    }),
    and: createToken({
        name: 'and',
        pattern: /\band\b/,
        start_chars_hint: ["a"],
        line_breaks: false,
    }),
    array: createToken({
        name: 'array',
        pattern: /\barray\b/,
        start_chars_hint: ["a"],
        line_breaks: false,
    }),
    call: createToken({
        name: 'call',
        pattern: /\bcall\b/,
        start_chars_hint: ["c"],
        line_breaks: false,
    }),
    constant: createToken({
        name: 'constant',
        pattern: /\bconstant\b/,
        start_chars_hint: ["c"],
        line_breaks: false,
    }),
    debug: createToken({
        name: 'debug',
        pattern: /\bdebug\b/,
        start_chars_hint: ["d"],
        line_breaks: false,
    }),
    else: createToken({
        name: 'else',
        pattern: /\belse\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    elseif: createToken({
        name: 'elseif',
        pattern: /\belseif\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    endfunction: createToken({
        name: 'endfunction',
        pattern: /\bendfunction\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    endglobals: createToken({
        name: 'endglobals',
        pattern: /\bendglobals\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    endif: createToken({
        name: 'endif',
        pattern: /\bendif\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    endloop: createToken({
        name: 'endloop',
        pattern: /\bendloop\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    exitwhen: createToken({
        name: 'exitwhen',
        pattern: /\bexitwhen\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    extends: createToken({
        name: 'extends',
        pattern: /\bextends\b/,
        start_chars_hint: ["e"],
        line_breaks: false,
    }),
    function: createToken({
        name: 'function',
        pattern: /\bfunction\b/,
        start_chars_hint: ["f"],
        line_breaks: false,
    }),
    globals: createToken({
        name: 'globals',
        pattern: /\bglobals\b/,
        start_chars_hint: ["g"],
        line_breaks: false,
    }),
    if: createToken({
        name: 'if',
        pattern: /\bif\b/,
        start_chars_hint: ["i"],
        line_breaks: false,
    }),
    local: createToken({
        name: 'local',
        pattern: /\blocal\b/,
        start_chars_hint: ["l"],
        line_breaks: false,
    }),
    loop: createToken({
        name: 'loop',
        pattern: /\bloop\b/,
        start_chars_hint: ["l"],
        line_breaks: false,
    }),
    native: createToken({
        name: 'native',
        pattern: /\bnative\b/,
        start_chars_hint: ["n"],
        line_breaks: false,
    }),
    not: createToken({
        name: 'not',
        pattern: /\bnot\b/,
        start_chars_hint: ["n"],
        line_breaks: false,
    }),
    nothing: createToken({
        name: 'nothing',
        pattern: /\bnothing\b/,
        start_chars_hint: ["n"],
        line_breaks: false,
    }),
    or: createToken({
        name: 'or',
        pattern: /\bor\b/,
        start_chars_hint: ["o"],
        line_breaks: false,
    }),
    returns: createToken({
        name: 'returns',
        pattern: /\breturns\b/,
        start_chars_hint: ["r"],
        line_breaks: false,
    }),
    return: createToken({
        name: 'return',
        pattern: /\breturn\b/,
        start_chars_hint: ["r"],
        line_breaks: false,
    }),
    set: createToken({
        name: 'set',
        pattern: /\bset\b/,
        start_chars_hint: ["s"],
        line_breaks: false,
    }),
    takes: createToken({
        name: 'takes',
        pattern: /\btakes\b/,
        start_chars_hint: ["t"],
        line_breaks: false,
    }),
    then: createToken({
        name: 'then',
        pattern: /\bthen\b/,
        start_chars_hint: ["t"],
        line_breaks: false,
    }),
    type: createToken({
        name: 'type',
        pattern: /\btype\b/,
        start_chars_hint: ["t"],
        line_breaks: false,
    }),
    comma: createToken({
        name: 'comma',
        pattern: /,/,
        start_chars_hint: [","],
        label: ",",
        line_breaks: false,
    }),
    equals: createToken({
        name: 'equals',
        pattern: /==/,
        start_chars_hint: ["="],
        line_breaks: false,
        label: "==",
    }),
    assign: createToken({
        name: 'assign',
        pattern: /=/,
        start_chars_hint: ["="],
        line_breaks: false,
        label: "=",
    }),
    notequals: createToken({
        name: 'notequals',
        pattern: /!=/,
        start_chars_hint: ["!"],
        line_breaks: false,
        label: "!=",
    }),
    lessorequal: createToken({
        name: 'lessorequal',
        pattern: /<=/,
        start_chars_hint: ["<"],
        line_breaks: false,
        label: "<=",
    }),
    less: createToken({
        name: 'less',
        pattern: /</,
        start_chars_hint: ["<"],
        line_breaks: false,
        label: "<",
    }),
    greatorequal: createToken({
        name: 'greatorequal',
        pattern: />=/,
        start_chars_hint: [">"],
        line_breaks: false,
        label: ">=",
    }),
    great: createToken({
        name: 'great',
        pattern: />/,
        start_chars_hint: [">"],
        line_breaks: false,
        label: ">",
    }),
    add: createToken({
        name: 'add',
        pattern: /\+/,
        start_chars_hint: ["+"],
        line_breaks: false,
        label: "+",
    }),
    sub: createToken({
        name: 'sub',
        pattern: /-/,
        start_chars_hint: ["-"],
        line_breaks: false,
        label: "-",
    }),
    mult: createToken({
        name: 'mult',
        pattern: /\*/,
        start_chars_hint: ["*"],
        line_breaks: false,
        label: "*",
    }),
    div: createToken({
        name: 'div',
        pattern: /\//,
        start_chars_hint: ["/"],
        line_breaks: false,
        label: "/",
    }),
    lparen: createToken({
        name: 'lparen',
        pattern: /\(/,
        start_chars_hint: ["("],
        line_breaks: false,
        label: "(",
    }),
    rparen: createToken({
        name: 'rparen',
        pattern: /\)/,
        start_chars_hint: [")"],
        line_breaks: false,
        label: ")",
    }),
    lsquareparen: createToken({
        name: 'lsquareparen',
        pattern: /\[/,
        start_chars_hint: ["["],
        line_breaks: false,
        label: "[",
    }),
    rsquareparen: createToken({
        name: 'rsquareparen',
        pattern: /]/,
        start_chars_hint: ["]"],
        line_breaks: false,
        label: "]",
    }),
    real: createToken({
        name: 'real',
        pattern: /[0-9]+\.[0-9]+/,
        line_breaks: false,
    }),
    integer: createToken({
        name: 'integer',
        pattern: /0x[0-9a-z]+|\$[0-9a-z]+|\d+/i,
        line_breaks: false,
    }),
    linebreak: createToken({
        name: 'linebreak',
        pattern: /\n|\r\n/,
        label: "\\n",
        line_breaks: true,
    }),
    idliteral: createToken({
        name: 'idliteral',
        pattern: /'[^']*'/,
        line_breaks: true,
    }),
    stringliteral: createToken({
        name: 'stringliteral',
        pattern: /"[^"\\]*(?:\\.[^"\\]*)*"/,
        start_chars_hint: ["\""],
        line_breaks: true,
    }),
    identifier: createToken({
        name: 'identifier',
        pattern: /[a-zA-Z][a-zA-Z0-9_]*/,
        line_breaks: false,
    }),
}
